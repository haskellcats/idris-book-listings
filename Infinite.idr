||| A type is infinite if there is a function f from t -> t such that
|||
||| f is injective and
|||
||| there is a target : t which f does not send anything to
|||
||| (translation of "a set is infinite if theres an injection to a proper subset of itself")
data IsInfinite : Type -> Type where
  MkIsInfinite :
    (f : t -> t) ->
    (inj : (x, y : t) -> f x = f y -> x = y) ->
    (target : t) ->
    (missed : (z : t ** f z = target) -> Void) ->
    IsInfinite t

||| Hilbert's hotel moves all the residents up 1, leaving 0 empty
hilbert : Nat -> Nat
hilbert n = 1 + n -- note using n + 1 would require a commutativity proof

||| Hilbert's hotel function is injective
hilbertInj : (x : Nat) -> (y : Nat) -> (hilbert x = hilbert y) -> x = y
hilbertInj Z Z Refl = Refl
hilbertInj Z (S k) Refl impossible
hilbertInj (S _) Z Refl impossible
hilbertInj (S j) (S j) Refl = Refl

||| If hilbert's function assigns something to 0, contradiction
missedTarg : (n ** hilbert n = 0) -> Void
missedTarg (x ** Refl) impossible

||| Put together hilberts hotel argument
natInf : IsInfinite Nat
natInf =
  let s1 = hilbert in
  let s2 = hilbertInj in
  let s3 = 0 in
  let s4 = missedTarg in
  MkIsInfinite s1 s2 s3 s4


||| Analyze any bool function
checkBool : (f : Bool -> Bool) -> ((a:Bool) -> (b:Bool) -> f False = a -> f True = b -> c) -> c
checkBool f g =
  let x = f False in
  let y = f True in
  g x y Refl Refl

||| A function from bool to bool is either surjective or sends both args to
||| the same place
data BoolFuncType : (Bool -> Bool) -> Type where
  SurjB : ((y : Bool) -> (x : Bool ** f x = y)) -> BoolFuncType f
  CollideB : (x,y : Bool) -> (x=y -> Void) -> (f x = f y) -> BoolFuncType f

-- These auxilliary preimage functions were generated by interactive proving
-- and are required to properly construct a BoolFuncType in the case of surjections

||| aux preimage function 1
pre1 : (f : Bool -> Bool) -> (prf1 : f False = False) -> (prf2 : f True = True) -> (y : Bool) -> (x : Bool ** f x = y)
pre1 f prf1 prf2 False = (False ** prf1)
pre1 f prf1 prf2 True = (True ** prf2)

||| aux preimage function 2
pre2 : (f : Bool -> Bool) -> (prf1 : f False = True) -> (prf2 : f True = False) -> (y : Bool) -> (x : Bool ** f x = y)
pre2 f prf1 prf2 False = (True ** prf2)
pre2 f prf1 prf2 True = (False ** prf1)

||| Determine whether the bool function is surjective or colliding
analyze : (f : Bool -> Bool) -> (a : Bool) -> (b : Bool) -> f False = a -> f True = b -> BoolFuncType f
analyze f False False prf1 prf2 = CollideB False True (trueNotFalse . sym) (trans prf1 (sym prf2))
analyze f False True prf1 prf2 = SurjB (pre1 f prf1 prf2)
analyze f True False prf1 prf2 = SurjB (pre2 f prf1 prf2)
analyze f True True prf1 prf2 = CollideB False True (trueNotFalse . sym) (trans prf1 (sym prf2))

||| Bool being infinite would be a contradiction
||| there are two ways an IsInfinite Bool proof could make no sense:
|||
||| 1. if the injection is a surjection, then the missed target isn't really missed
||| 2. if the injection is colliding, then it's not really an injection after all
boolNotInf : IsInfinite Bool -> Void
boolNotInf (MkIsInfinite f inj targ missed) = case checkBool f (analyze f) of
  (SurjB pre) => missed (pre targ)
  (CollideB x y xyNotEqual imagesEqual) => xyNotEqual (inj x y imagesEqual)


||| A type is finite if all injections are surjections
data IsFinite : Type -> Type where
  MkIsFinite : ((f : t -> t) -> ((x,y : t) -> f x = f y -> x = y) -> (z : t) -> (w : t ** f w = z)) -> IsFinite t

||| Given an injection on Bool, build a surjection
boolSurj : (f : Bool -> Bool) -> ((x : Bool) -> (y : Bool) -> (f x = f y) -> x = y) -> (z : Bool) -> (w : Bool ** f w = z)
boolSurj f inj z with (checkBool f (analyze f))
  boolSurj f inj False | (SurjB pre) = pre False
  boolSurj f inj _ | (CollideB x y xyNotEqual imagesEqual) = void (xyNotEqual (inj x y imagesEqual))
  boolSurj f inj True | (SurjB pre) = pre True
  boolSurj f inj _ | (CollideB x y xyNotEqual imagesEqual) = void (xyNotEqual (inj x y imagesEqual))

||| Bool is finite
boolFin : IsFinite Bool
boolFin = let p = boolSurj in MkIsFinite p


||| Nat is not finite
|||
||| The argument is: hilbert's hotel is an injection, so being finite would
||| imply that it is also a surjection. But we know it doesn't assign anything
||| to zero, so reversing the surjection at zero is nonsense.
|||
||| I didn't really know what it would return, but it turned out to be a proof
||| that zero equals a successor. ZnotS is a library defined eliminator for this.
natNotFinite : IsFinite Nat -> Void
natNotFinite (MkIsFinite injToSurj) = case injToSurj hilbert hilbertInj 0 of
  (_ ** zeroIsASuccOfSomething) => ZnotS (sym zeroIsASuccOfSomething)


||| Finite implies Not Infinite and vice versa
|||
||| This is the same argument as hilbert's hotel, only generalized to any
||| type which claims to be finite and infinite at the same time. If you convert
||| the "infinite" injection to a surjection, then the missed target can be
||| reversed to arrived at a non existent starting point.
finNotInf : IsFinite t -> IsInfinite t -> Void
finNotInf (MkIsFinite injToSurj) (MkIsInfinite f inj target missed) =
  missed (injToSurj f inj target)
